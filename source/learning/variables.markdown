---
layout: default
title: Learning — Variables, Conditionals, and Facts
---

Learning — Variables, Conditionals, and Facts
=============================================

You understand how to write manifests and order resources; now use conditional statements and variables to add logic and flexibility to your resource declarations.

* * *

&larr; [Ordering](./ordering.html) --- [Index](./) --- TBA &rarr;

* * * 

[customfacts]: http://docs.puppetlabs.com/guides/custom_facts.html

Variables
---------

Just for the sake of moving a little faster, have some bullet points:

* `$variables` always start with a dollar sign.
* They can hold strings, numbers, arrays, and hashes.
* You can use variables as a value for any attribute, or even as the title of a resource. 
* If you use double-quotes, you can interpolate variables inside strings. To distinguish a `${variable}` from the surrounding text, you should wrap its name in curly braces.
* Every variable has a short name and a fully-qualified name. Fully qualified variables look like `$scope::variable`. Top scope variables are the same, but their scope is nameless: `$::top_scope_variable`.
    * (You don't actually need to know that yet! I'm just throwing it in there to get you used to it early.) 
* You can only declare the same variable **once** in a given scope.[^declarative]

[^declarative]: This has to do with the declarative nature of the Puppet language: the idea is that the order in which you read the file shouldn't matter, so changing a value halfway through is illegal, since it would make the results order-dependent. <br><br>In practice, this isn't the full story, and you can't currently read a variable anywhere north of its declaration. We're working on that.

So, the easiest way to start taking advantage of variables is just to make your code cleaner:

    $longthing = "Imagine I have something really long in here. Like an SSH key, let's say."
    
    file {'authorized_keys':
      path    => '/root/.ssh/authorized_keys',
      content => $longthing,
    }

But that, of course, is just the beginning. 

True Facts
----------

Before you even start writing your manifests, Puppet prepares you a huge supply of pre-declared variables. Check it out:

{% highlight ruby %}
    # facts-simple.pp
    
    host {'self':
      ensure => present,
      name   => $::hostname,
      ip     => $::ipaddress,
    }
    
    file {'motd':
      ensure  => file,
      path    => '/etc/motd',
      mode    => 0644,
      content => "Welcome to ${::hostname},\n a ${::operatingsystem} island in the sea of ${::domain}.\n",
    }
{% endhighlight %}
    
    # puppet apply hosts-simple.pp
    
    notice: /Stage[main]//Host[puppet]/ensure: created
    notice: /Stage[main]//File[motd]/ensure: defined content as '{md5}d149026e4b6d747ddd3a8157a8c37679'
    
    # cat /etc/hosts
    # HEADER: This file was autogenerated at Mon Apr 25 14:39:11 -0700 2011
    # HEADER: by puppet.  While it can still be managed manually, it
    # HEADER: is definitely not recommended.
    # Do not remove the following line, or various programs
    # that require network functionality will fail.
    127.0.0.1	localhost.localdomain	localhost
    ::1	localhost6.localdomain6	localhost6
    172.16.158.137	puppet

Yes. I just taught you a magic spell. We're now starting to write manifests that will do the right thing no matter which machine you apply them to.

It's Actually Not Magical At All
--------------------------------

So Puppet ships with a tool called Facter, which ferrets out your system information, normalizes it, and passes it off to Puppet. The compiler has access to all of those facts when it's reading a manifest, and exposes them as top-scope variables.

Since the next question is probably "How in the world am I supposed to know what all these variables are," try running:

    # facter

...at your VM's command line, and you'll get back a long list of key/value pairs separated by the familiar `=>` hash rocket. Prepend a dollar sign (and a `::`, because being explicit about scope is a good habit) to a fact name, and you can insert its value anywhere in your manifests. 

Most kinds of system will have at least a few facts that aren't available on other kinds of system (e.g., try comparing Facter's output on your CentOS VM to what it does on an OS X box), but there's a general core of facts that give you the same info everywhere. You'll get a feel for them pretty quickly, and can probably guess most of them just by reading the list of names. 

Variables
---------

Puppet exposes everything it gets from Facter as global variables.

In Puppet, all `$variables` start with a dollar sign. They can be referenced bare or in double-quoted strings, but not in single-quoted strings. To distinguish a `${variable}` from the surrounding text, you can optionally wrap its name in curly braces.

So let's get our `/etc/hosts` file in order without bothering to look up our actual IP address! Memorizing long strings of digits is so last century.


Assigning Variables
-------------------




### An Aside: Scope and Namespaces

I mentioned that facts are global 

Without going into too much detail, I want to mention that current versions of Puppet 