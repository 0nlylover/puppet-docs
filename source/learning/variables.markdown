---
layout: default
title: Learning — Variables, Conditionals, and Facts
---

Learning — Variables, Conditionals, and Facts
=============================================

You understand how to write manifests and order resources; now use conditional statements and variables to add logic and flexibility to your resource declarations.

* * *

&larr; [Ordering](./ordering.html) --- [Index](./) --- TBA &rarr;

* * * 

[customfacts]: http://docs.puppetlabs.com/guides/custom_facts.html

Variables
---------

If you've ever scripted anything, a lot of this chapter will be very familiar. So in the interest of moving a little faster, let's do some bullet points:

* `$variables` always start with a dollar sign. You assign to variables with the `=` operator. 
* Variables can hold strings, numbers, arrays, and hashes.
* You can use variables as a value for any attribute, or even as the title of a resource. 
* If you use double-quotes, you can interpolate variables inside strings. To distinguish a `${variable}` from the surrounding text, you should wrap its name in curly braces.
* Every variable has a short name and a fully-qualified name. Fully qualified variables look like `$scope::variable`. Top scope variables are the same, but their scope is nameless: `$::top_scope_variable`.
* You can only assign the same variable **once** in a given scope.[^declarative]

[^declarative]: This has to do with the declarative nature of the Puppet language: the idea is that the order in which you read the file shouldn't matter, so changing a value halfway through is illegal, since it would make the results order-dependent. <br><br>In practice, this isn't the full story, because you can't currently read a variable anywhere north of its assignment. We're working on that.

The easiest way to start taking advantage of variables is just to make your code cleaner:

    $longthing = "Imagine I have something really long in here. Like an SSH key, let's say."
    
    file {'authorized_keys':
      path    => '/root/.ssh/authorized_keys',
      content => $longthing,
    }

But that, of course, is just the beginning. 

Facts
-----

Before you even start writing your manifests, Puppet builds a stash of pre-assigned variables. Check it out:

{% highlight ruby %}
    # facts-simple.pp
    
    # The type reference, as ever, is your friend:
    # http://docs.puppetlabs.com/references/latest/type.html#host
    
    host {'self':
      ensure => present,
      name   => $::hostname,
      ip     => $::ipaddress,
    }
    
    file {'motd':
      ensure  => file,
      path    => '/etc/motd',
      mode    => 0644,
      content => "Welcome to ${::hostname},\n a ${::operatingsystem} island in the sea of ${::domain}.\n",
    }
{% endhighlight %}
    
    # puppet apply hosts-simple.pp
    
    notice: /Stage[main]//Host[puppet]/ensure: created
    notice: /Stage[main]//File[motd]/ensure: defined content as '{md5}d149026e4b6d747ddd3a8157a8c37679'
    
    # cat /etc/hosts
    # HEADER: This file was autogenerated at Mon Apr 25 14:39:11 -0700 2011
    # HEADER: by puppet.  While it can still be managed manually, it
    # HEADER: is definitely not recommended.
    # Do not remove the following line, or various programs
    # that require network functionality will fail.
    127.0.0.1	localhost.localdomain	localhost
    ::1	localhost6.localdomain6	localhost6
    172.16.158.137	puppet

Our manifests are starting to get versatile. 

### Hostname? IPaddress?

So where did those helpful variables come from? They're "facts." Puppet ships with a tool called Facter, which ferrets out your system information, normalizes it into a set of variables, and passes them off to Puppet. The compiler then has access to those facts when it's reading a manifest. 

The next question is how you're supposed to know what all these facts are. Try running:

    # facter

...at your VM's command line, and you'll get back a long list of key/value pairs separated by the familiar `=>` hash rocket. Prepend a dollar sign (and a `::`, because being explicit about namespaces is a good habit) to a fact name, and you can insert its value anywhere in your manifests. 

Most kinds of system will have at least a few facts that aren't available on other kinds of system (e.g., try comparing Facter's output on your CentOS VM to what it does on an OS X machine), and it can get fuzzier if you're extending Facter with [custom facts](/guides/custom_facts.html), but there's a general core of facts that give you the same info everywhere. You'll get a feel for them pretty quickly, and can probably guess most of them just by reading the list of names. Getting better documentation for the various facts and their possible values is... well, it's on the list. You know how it is.

Conditional Statements
----------------------

### If

Moving a little faster again, let's get straight to the basic `if` you've been waiting for:

{% highlight ruby %}
    if $is_virtual {
      service {'ntpd':
        ensure => stopped,
        enable => false,
      }
    }
    else {
      TK insert example NTP configuration here
    }
{% endhighlight %}

"If" statements are done with the standard `if` / `elsif` / `else` keywords. `if` and `elsif` take a condition, and all of the keywords take {a block of Puppet code}, which can have resource declarations, variable assignments, relationship declarations, collections, and more. 

#### What is False?

The Puppet language's data types are kind of loose, and a lot of things tend to get represented internally as strings. The following values will be treated as false by an if statement:

* `undef`
* `''` (the empty string)
* `false`

#### Conditions

[expression]: http://docs.puppetlabs.com/guides/language_guide.html#expressions

Conditions can get pretty sophisticated: you can use any valid [expression][] in an if statement. Usually, this is going to mean using one of the standard comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`), the regex match operators (`=~` and `!~`), or the `in` operator (which tests whether the right operand contains the left one).

### Case

Also probably familiar: the case statement. (Or switch, or whatever it's called in your programming language of choice.) 

    case $operatingsystem {
      centos: { $apache = "httpd" }
      redhat: { $apache = "httpd" }
      debian: { $apache = "apache2" }
      ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
      # "fail" is a function. We'll get to those later.
    }
    package {'apache':
      name => $apache,
      ensure => latest,
    }

Instead of testing a condition up front, `case` takes a variable to test against; then, inside the curly braces, it takes a list of possible values, each of which has a block of Puppet code. 

