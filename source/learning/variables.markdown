---
layout: default
title: Learning — Variables, Conditionals, and Facts
---

Learning — Variables, Conditionals, and Facts
=============================================

You can write manifests and order resources; now, conditional statements and variables will add logic and flexibility.

* * *

&larr; [Ordering](./ordering.html) --- [Index](./) --- TBA &rarr;

* * * 

[customfacts]: http://docs.puppetlabs.com/guides/custom_facts.html

Variables
---------

If you've ever scripted anything, a lot of this chapter will be very familiar. So in the interest of moving a little faster, let's do some bullet points:

* `$variables` always start with a dollar sign. You assign to variables with the `=` operator. 
* Variables can hold strings, numbers, arrays, and hashes.
* You can use variables as the value for any resource attribute, or even as the title of a resource. 
* You can also interpolate variables inside strings, if you use double-quotes. To distinguish a `${variable}` from the surrounding text, you should wrap its name in curly braces.
* Every variable has a short name and a fully-qualified name. Fully qualified variables look like `$scope::variable`. Top scope variables are the same, but their scope is nameless: `$::top_scope_variable`.
* You can only assign the same variable **once** in a given scope.[^declarative]

[^declarative]: This has to do with the declarative nature of the Puppet language: the idea is that the order in which you read the file shouldn't matter, so changing a value halfway through is illegal, since it would make the results order-dependent. <br><br>In practice, this isn't the full story, because you can't currently read a variable anywhere north of its assignment. We're working on that.

The easiest way to start taking advantage of variables is just to make your code cleaner:

    $longthing = "Imagine I have something really long in here. Like an SSH key, let's say."
    
    file {'authorized_keys':
      path    => '/root/.ssh/authorized_keys',
      content => $longthing,
    }

But that, of course, is just the beginning. 

Facts
-----

Before you even start writing your manifests, Puppet builds a stash of pre-assigned variables. Check it out:

{% highlight ruby %}
    # facts-simple.pp
    
    # The type reference, as ever, is your friend:
    # http://docs.puppetlabs.com/references/latest/type.html#host
    
    host {'self':
      ensure => present,
      name   => $::hostname,
      ip     => $::ipaddress,
    }
    
    file {'motd':
      ensure  => file,
      path    => '/etc/motd',
      mode    => 0644,
      content => "Welcome to ${::hostname},\n a ${::operatingsystem} island in the sea of ${::domain}.\n",
    }
{% endhighlight %}
    
    # puppet apply hosts-simple.pp
    
    notice: /Stage[main]//Host[puppet]/ensure: created
    notice: /Stage[main]//File[motd]/ensure: defined content as '{md5}d149026e4b6d747ddd3a8157a8c37679'
    
    # cat /etc/hosts
    # HEADER: This file was autogenerated at Mon Apr 25 14:39:11 -0700 2011
    # HEADER: by puppet.  While it can still be managed manually, it
    # HEADER: is definitely not recommended.
    # Do not remove the following line, or various programs
    # that require network functionality will fail.
    127.0.0.1	localhost.localdomain	localhost
    ::1	localhost6.localdomain6	localhost6
    172.16.158.137	puppet

Our manifests are starting to get versatile. 

### Hostname? IPaddress?

So where did those helpful variables come from? They're "facts." Puppet ships with a tool called Facter, which ferrets out your system information, normalizes it into a set of variables, and passes them off to Puppet. The compiler then has access to those facts when it's reading a manifest. 

The next question is how you're supposed to know what all these facts are. Try running:

    # facter

...at your VM's command line, and you'll get back a long list of key/value pairs separated by the familiar `=>` hash rocket. Prepend a dollar sign (and a `::`, because being explicit about namespaces is a good habit) to a fact name, and you can insert its value anywhere in your manifests. 

Most kinds of system will have at least a few facts that aren't available on other kinds of system (e.g., try comparing Facter's output on your CentOS VM to what it does on an OS X machine), and it can get fuzzier if you're extending Facter with [custom facts](/guides/custom_facts.html), but there's a general core of facts that give you the same info everywhere. You'll get a feel for them pretty quickly, and can probably guess most of them just by reading the list of names. Getting better documentation for the various facts and their possible values is... well, it's on the list. You know how it is.

Conditional Statements
----------------------

### If

Moving a little faster again, let's get straight to the basic `if` you've been waiting for:

{% highlight ruby %}
    if $is_virtual {
      service {'ntpd':
        ensure => stopped,
        enable => false,
      }
    }
    else {
      TK insert example NTP configuration here
    }
{% endhighlight %}

"If" statements are done with the standard `if` / `elsif` / `else` keywords. `if` and `elsif` take a condition, and all of the keywords take {a block of Puppet code}, which can have resource declarations, variable assignments, relationship declarations, collections, and more. 

#### What is False?

The Puppet language's data types are kind of loose, and a lot of things tend to get represented internally as strings. The following values will be treated as false by an if statement:

* `undef`
* `''` (the empty string)
* `false`

#### Conditions

[expression]: http://docs.puppetlabs.com/guides/language_guide.html#expressions

Conditions can get pretty sophisticated: you can use any valid [expression][] in an if statement. Usually, this is going to mean using one of the standard comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`), the regex match operators (`=~` and `!~`), or the `in` operator (which tests whether the right operand contains the left one).

### Case

Also probably familiar: the case statement. (Or switch, or whatever it's called in your programming language of choice.) 

{% highlight ruby %}
    case $operatingsystem {
      centos: { $apache = "httpd" }
      # Note that these matches are case-insensitive.
      redhat: { $apache = "httpd" }
      debian: { $apache = "apache2" }
      ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
      # "fail" is a function. We'll get to those later.
    }
    package {'apache':
      name   => $apache,
      ensure => latest,
    }
{% endhighlight %}

Instead of testing a condition up front, `case` takes a variable to test against and a bunch of possible matches. The `default` you see there is a special match that does exactly what it sounds like. 

Matches can be simple strings, like you see above, or they can be comma-separated lists of strings. The example could (and should!) be rewritten like this: 

{% highlight ruby %}
    case $operatingsystem {
      centos, redhat: { $apache = "httpd" }
      debian, ubuntu: { $apache = "apache2" }
      default: { fail("Unrecognized operating system for webserver") }
    }
{% endhighlight %}

You can also use regular expressions: 

{% highlight ruby %}
    case $ipaddress_eth0 {
      /^127\./: { notify {'Possible network misconfiguration!': } }
    }
{% endhighlight %}

(And inside the code block for a regex match, you can use `$1`, `$2`, etc. to print captured strings, with `$0` containing the whole match.)

### Selector

Selectors might be less familiar; they're kind of like the ternary operator, and kind of like the case statement. 

Unlike the other two types of conditionals, selectors don't take code blocks. Instead, they simply return a value, for either a resource attribute or a variable assignment. 